library(geostatbook)
library(remotes)
library(geostatbook)
remotes::install_github("nowosad/geostatbook@3")
remotes::install_github("nowosad/geostatbook@2")
library(sf)
library(stars)
library(gstat)
library(pgirmess)
library(ggplot2)
library(geostatbook)
data(punkty)
library(remotes)
remotes::install_github("nowosad/geostatbook@3")
install.packages("dismo")
updateR()
install.packages("installr")
library(installr)
updateR()
install.packages("dismo")
updateR()
install.packages("dismo")
install.packages("remotes")
library(sf)
install.packages("sf")
library(stars)
install.packages("stars")
install.packages("ggplot2")
library(remotes)
remotes::install_github("nowosad/geostatbook@3")
library(sf)
library(stars)
library(gstat)
library(pgirmess)
library(ggplot2)
library(geostatbook)
data(punkty)
data(siatka)
data(granica)
data(punkty)
data(siatka)
data(granica)
#Zad_1
data(punkty_pref)
head(punkty_pref)
hscat(temp~1, data = punkty, breaks = seq(0, 4000, by = 500))
hscat(temp~1, data = punkty, breaks = seq(0, 5000, by = 625))
vario_map_1 = variogram(srtm ~ 1, locations = punkty_pref,
cutoff = 3000, width = 500, map = TRUE)
# co najmniej 30 par punktów
plot(vario_map_1, threshold = 30,
col.regions = hcl.colors(40, palette = "ag_GrnYl", rev = TRUE))
vario_map_1 = variogram(srtm ~ 1, locations = punkty_pref,
cutoff = 3000, width = 500, map = TRUE)
#lab_5
library(sf)
library(stars)
library(gstat)
library(pgirmess)
library(ggplot2)
library(geostatbook)
data(punkty)
data(siatka)
data(granica)
data(punkty_pref)
hscat(temp~1, data = punkty_pref, breaks = seq(0, 5000, by = 625))
# Zad_2
# Wylicz odległość oraz wartość semiwariancji dla zmiennej srtm pomiędzy pierwszym i
# drugim, pierwszym i trzecim, oraz drugim i trzecim punktem. Zwizualizuj te trzy punkty.
# W jaki sposób można zinterpretować otrzymane wyniki wartości semiwariancji?
odl_1 = st_distance(punkty_pref[c(1, 2), ])[2]
odl_1
odl_2 = st_distance(punkty_pref[c(1, 3), ])[2]
odl_2
odl_3 = st_distance(punkty_pref[c(2, 3), ])[2]
odl_3
gamma_1 = 0.5 * (punkty_pref$srtm[1] - punkty_pref$srtm[2]) ^ 2
gamma_1
gamma_2 = 0.5 * (punkty_pref$srtm[1] - punkty_pref$srtm[3]) ^ 2
gamma_2
gamma_3 = 0.5 * (punkty_pref$srtm[2] - punkty_pref$srtm[3]) ^ 2
gamma_3
plot(punkty_pref$srtm[1:3])
vario_cloud = variogram(temp ~ 1, locations = punkty_pref,
cloud = TRUE)
plot(vario_cloud)
vario_cloud_sel = plot(vario_cloud, digitize = TRUE)
plot(vario_cloud_sel, punkty_pref)
0.5 * nrow(punkty_pref) * (nrow(punkty_pref) - 1)
pow_pr = (st_area(granica)/1000000) / nrow(punkty_pref)
sqrt(pow_pr)
vario_par = variogram(srtm ~ 1, locations = punkty_pref)
vario_par
plot(vario_par)
vario_par = variogram(srtm ~ 1, locations = punkty_pref,
cutoff = 3500)
plot(vario_par)
vario_map_1 = variogram(srtm ~ 1, locations = punkty_pref,
cutoff = 3000, width = 500, map = TRUE)
vario_map_2 = variogram(srtm ~ 1, locations = punkty_pref,
cutoff = 4000, width = 350, map = TRUE)
vario_map_3 = variogram(srtm ~ 1, locations = punkty_pref,
cutoff = 5000, width = 200, map = TRUE)
# co najmniej 30 par punktów
plot(vario_map_1, threshold = 30,
col.regions = hcl.colors(40, palette = "ag_GrnYl", rev = TRUE))
# co najmniej 30 par punktów
plot(vario_map_3, threshold = 30,
col.regions = hcl.colors(40, palette = "ag_GrnYl", rev = TRUE))
# co najmniej 30 par punktów
plot(vario_map_2, threshold = 30,
col.regions = hcl.colors(40, palette = "ag_GrnYl", rev = TRUE))
vario_map_2 = variogram(srtm ~ 1, locations = punkty_pref,
cutoff = 4000, width = 400, map = TRUE)
# co najmniej 30 par punktów
plot(vario_map_2, threshold = 30,
col.regions = hcl.colors(40, palette = "ag_GrnYl", rev = TRUE))
vario_map_2 = variogram(srtm ~ 1, locations = punkty_pref,
cutoff = 4000, width = 500, map = TRUE)
# co najmniej 30 par punktów
plot(vario_map_2, threshold = 30,
col.regions = hcl.colors(40, palette = "ag_GrnYl", rev = TRUE))
install.packages("viridisLite")
library(viridisLite)
?viridisLite
viridis.map
# co najmniej 30 par punktów
plot(vario_map_2, threshold = 30,
col.regions = hcl.colors(40, palette = "viridi", rev = TRUE))
# co najmniej 30 par punktów
plot(vario_map_2, threshold = 30,
col.regions = hcl.colors(40, palette = "viridis", rev = TRUE))
# co najmniej 30 par punktów
plot(vario_map_2, threshold = 30,
col.regions = hcl.colors(40, palette = "ag_GrnYl", rev = TRUE))
# co najmniej 30 par punktów
plot(vario_map_2, threshold = 30,
col.regions = hcl.colors(40, palette = "inferno", rev = TRUE))
# co najmniej 30 par punktów
plot(vario_map_2, threshold = 30,
col.regions = hcl.colors(40, palette = "inferno", rev = TRUE))
vario_kier = variogram(srtm ~ 1, locations = punkty_pref,
alpha = c(0, 45, 90, 135))
plot(vario_kier)
# co najmniej 30 par punktów
plot(vario_map_2, threshold = 30,
col.regions = hcl.colors(40, palette = "inferno", rev = TRUE))
vario_kier = variogram(srtm ~ 1, locations = punkty_pref,
alpha = c(0, 45, 90, 135))
plot(vario_kier)
# co najmniej 30 par punktów
plot(vario_map_2, threshold = 30,
col.regions = hcl.colors(40, palette = "inferno", rev = TRUE))
vario_kier = variogram(srtm ~ 1, locations = punkty_pref,
alpha = c(0, 45, 135, 225))
plot(vario_kier)
library(sf)
library(stars)
library(gstat)
library(tmap)
library(geostatbook)
data(punkty)
data(punkty_ndvi)
data(siatka)
data("meuse.all")
meuse = st_as_sf(meuse.all, coords = c("x", "y"))
set.seed(431)
meuse164 = meuse["cadmium"]
meuse60 = meuse[sample(nrow(meuse), 60), "copper"]
# zad 1
punkty_bbox = st_bbox(meuse)
nowa_siatka = st_as_stars(punkty_bbox,
dx = 100,
dy = 100)
nowa_siatka = st_set_crs(nowa_siatka, "EPSG:2180")
plot(nowa_siatka)
tm_shape(nowa_siatka) +
tm_shape(raster)
tm_shape(nowa_siatka) +
tm_raster()
# Zad 2 Zbuduj optymalne modele semiwariogramu zmiennej cadmium dla obiektu meuse164 oraz
# zmiennej copper dla obiektu meuse60. Porównaj graficznie uzyskane modele.
View(meuse164)
sem_meuse164 = variogram(cadmium ~ 1, locations = meuse164)
sem_meuse164
sem_meuse60 = variogram(copper ~ 1, locations = meuse60)
sem_meuse60
# Zad 2 Zbuduj optymalne modele semiwariogramu zmiennej cadmium dla obiektu meuse164 oraz
# zmiennej copper dla obiektu meuse60. Porównaj graficznie uzyskane modele.
View(meuse60)
plot(sem_meuse60, plot.numbers = TRUE)
meuse164
vario_164 = variogram(cadmium ~ 1, locations = meuse164)
model_164 = vgm(20, model = "Sph", range = 6000, nugget = 7.5)
fit_model = fit.variogram(vario_164, model_164)
plot(vario, model = fit_model)
plot(vario_164, model = fit_model)
# Zad 2 Zbuduj optymalne modele semiwariogramu zmiennej cadmium dla obiektu meuse164 oraz
# zmiennej copper dla obiektu meuse60. Porównaj graficznie uzyskane modele.
View(meu1640)
# Zad 2 Zbuduj optymalne modele semiwariogramu zmiennej cadmium dla obiektu meuse164 oraz
# zmiennej copper dla obiektu meuse60. Porównaj graficznie uzyskane modele.
View(meu164)
# Zad 2 Zbuduj optymalne modele semiwariogramu zmiennej cadmium dla obiektu meuse164 oraz
# zmiennej copper dla obiektu meuse60. Porównaj graficznie uzyskane modele.
View(meuse164)
model_164 = vgm(0, model = "Sph", range = 6000, nugget = 7.5)
fit_model = fit.variogram(vario_164, model_164)
plot(vario_164, model = fit_model)
model_164 = vgm(12, model = "Sph", range = 6000)
fit_model = fit.variogram(vario_164, model_164)
plot(vario_164, model = fit_model)
model_164 = vgm(20, model = "Sph", range = 6000)
fit_model = fit.variogram(vario_164, model_164)
plot(vario_164, model = fit_model)
model_164 = vgm(20, model = "Sph", range = 6000, nugget = 7.5)
fit_model = fit.variogram(vario_164, model_164)
plot(vario_164, model = fit_model)
model_164 = vgm(20, model = "Sph", range = 6000, nugget = 0)
fit_model = fit.variogram(vario_164, model_164)
plot(vario_164, model = fit_model)
model_164 = vgm(20, model = "Sph", range = 6000)
fit_model = fit.variogram(vario_164, model_164)
plot(vario_164, model = fit_model)
model_164 = vgm(30, model = "Sph", range = 6000)
fit_model = fit.variogram(vario_164, model_164)
plot(vario_164, model = fit_model)
model_164 = vgm(20, model = "Sph", range = 6000, nugget = 5)
fit_model = fit.variogram(vario_164, model_164)
plot(vario_164, model = fit_model)
model_164 = vgm(20, model = "Sph", range = 6000, nugget = 6)
fit_model = fit.variogram(vario_164, model_164)
plot(vario_164, model = fit_model)
vario_60 = variogram(copper ~ 1, locations = meuse60)
model_60 = vgm(20, model = "Sph", range = 6000, nugget = 6)
fit_model = fit.variogram(vario_60, model_60)
plot(vario_60, model = fit_model)
vario_60
model_60 = vgm(200, model = "Sph", range = 6000, nugget = 6)
fit_model = fit.variogram(vario_60, model_60)
plot(vario_60, model = fit_model)
model_60 = vgm(200, model = "Sph", range = 6000, nugget = 180)
fit_model = fit.variogram(vario_60, model_60)
plot(vario_60, model = fit_model)
model_60 = vgm(1000, model = "Sph", range = 6000, nugget = 180)
fit_model = fit.variogram(vario_60, model_60)
plot(vario_60, model = fit_model)
library(readxl)
a <- function(a, b){
print(1.5 * (a * b)^0.3)
}
a(2, 3)
a <- function(a, b){
print(1.5 * ((a * b)^0.3))
}
a(2, 3)
a(29.48825, 13.20468)
a(25.35306, 13.79887)
a(27.53923, 12.53368)
a(2.83118, 1.60121)
a(21.63766, 10.40696)
a(21.93692, 11.93868)
a(23.95534, 11.09722)
a(16.82482, 6.65407)
a(25.08983, 10.79921)
a(15.40244, 7.02311)
a(17.00252, 6.05431)
library(dplyr)
library(sf)
library(tmap)
library(kableExtra)
library(pals)
library(ggplot2)
library(areal)
library(gridExtra)
library(colourpicker)
entropy_fnc = function(proportions, base = exp(1)) {
entr = -sum(ifelse(proportions > 0, proportions * log(proportions, base = base), 0))
return(entr)
}
entropy_std_fnc = function(proportions, base = exp(1)) {
entr = -sum(ifelse(proportions > 0, proportions * log(proportions, base = base), 0)) #obliczenie entropii
entr_std = entr/log(length(proportions), base = base) #standaryzacja
return(entr_std)
}
d_ind = function(a, b) {
d = 0.5*sum(abs(a/sum(a, na.rm=TRUE) - b/sum(b, na.rm=TRUE)))
return(d)
}
hindex <- function(races) {
#races_all to liczba osob w calym obszarze w podziale na grupy rasowo-etniczne
races_all = apply(races, 2, sum, na.rm=TRUE)
#liczba osob w calym obszarze
pop = sum(races_all, na.rm=TRUE)
#liczba osob w kazdej jednostce spisowej
pop_i = apply(races, 1, sum, na.rm=TRUE)
#odsetek osob w danej grupy rasowo-etnicznej w kazdej jednostce spisowej
proportions = races/pop_i
#odsetek osob w danej grupy rasowo-etnicznej w calym obszarze
proportions_all = races_all/sum(races_all, na.rm = TRUE)
#entropia dla kazdej jednostki spisowej
ent_i = apply(proportions, 1, entropy_fnc)
#entropia dla calego obszaru
ent = entropy_fnc(proportions_all)
#obliczenie H
hind = sum(pop_i*(ent-ent_i)/(ent*pop), na.rm=TRUE)
return(hind)
}
tracts1990 = read_sf("dane/dane_przestrzenne/census_tracts_1990.shp")
tracts2000 = read_sf("dane/dane_przestrzenne/census_tracts_2000.shp")
dane_tracts_1990 = tracts1990[tracts1990$CNT_CODE == "39061",]
dane_tracts_2000 = tracts2000[tracts2000$CNT_CODE == "39061",]
fshp90 <- dane_tracts_1990
fshp00 <- dane_tracts_2000
rm(tracts1990, tracts2000, dane_tracts_1990, dane_tracts_2000)
list_race <- c("white", "black", "american", "asian", "others", "latin")
dat90 <- read_sf("dc_tract_1990_attr.shp")
dat00 <- read_sf("dc_tract_2000_attr.shp")
#target units - granice z 2020 roku
target_units <- dat00[, c("GISJOIN")]
#source units - dane w granicach z 1990 roku
source_units <- dat90[, c("GISJOIN", list_race, "POP")]
colnames(source_units) <- c("GJOIN", list_race, "POP", "geometry")
head(target_units)
# # Przyciecie granic jednostek zrodlowych oraz jednostek docelowych
intersect <- aw_intersect(target_units,
source = source_units,
areaVar = "area")
head(intersect)
intersect <- aw_total(intersect,
source = source_units, #granice zrodlowe
id = GJOIN, #id jednostek zrodlowych
areaVar = "area", #nazwa pola z powierzchnia jednostek z przeciecia, Ai
totalVar = "totalArea",
type = "extensive",
weight = "sum")
head(intersect)
intersect <- aw_weight(intersect,
areaVar = "area", #Ai - obliczane przez aw_intersect
totalVar = "totalArea", #Aj, obliczane przez aw_total
areaWeight = "areaWeight") #Wi
head(intersect)
#Jesli argument newVar nie zostanie podany, zostanie nadpisana wartosc w kolumnie value.
intersect <- aw_calculate(intersect,
value = "POP", #kolumna do przeliczenia
newVar = "POPnew", #nazwa nowej kolumny z przeliczonymi danymi.
areaWeight = "areaWeight") #wagi obliczone przez aw_weight()
result <- aw_aggregate(intersect,
target = target_units, #granice docelowe
tid = GISJOIN, #id docelowe (target units)
interVar = "POPnew") #nazwa przeliczonej zmiennej
library(dplyr)
library(sf)
library(tmap)
library(kableExtra)
library(pals)
library(ggplot2)
library(areal)
library(gridExtra)
library(colourpicker)
entropy_fnc = function(proportions, base = exp(1)) {
entr = -sum(ifelse(proportions > 0, proportions * log(proportions, base = base), 0))
return(entr)
}
entropy_std_fnc = function(proportions, base = exp(1)) {
entr = -sum(ifelse(proportions > 0, proportions * log(proportions, base = base), 0)) #obliczenie entropii
entr_std = entr/log(length(proportions), base = base) #standaryzacja
return(entr_std)
}
d_ind = function(a, b) {
d = 0.5*sum(abs(a/sum(a, na.rm=TRUE) - b/sum(b, na.rm=TRUE)))
return(d)
}
hindex <- function(races) {
#races_all to liczba osob w calym obszarze w podziale na grupy rasowo-etniczne
races_all = apply(races, 2, sum, na.rm=TRUE)
#liczba osob w calym obszarze
pop = sum(races_all, na.rm=TRUE)
#liczba osob w kazdej jednostce spisowej
pop_i = apply(races, 1, sum, na.rm=TRUE)
#odsetek osob w danej grupy rasowo-etnicznej w kazdej jednostce spisowej
proportions = races/pop_i
#odsetek osob w danej grupy rasowo-etnicznej w calym obszarze
proportions_all = races_all/sum(races_all, na.rm = TRUE)
#entropia dla kazdej jednostki spisowej
ent_i = apply(proportions, 1, entropy_fnc)
#entropia dla calego obszaru
ent = entropy_fnc(proportions_all)
#obliczenie H
hind = sum(pop_i*(ent-ent_i)/(ent*pop), na.rm=TRUE)
return(hind)
}
tracts1990 = read_sf("dane/dane_przestrzenne/census_tracts_1990.shp")
tracts2000 = read_sf("dane/dane_przestrzenne/census_tracts_2000.shp")
dane_tracts_1990 = tracts1990[tracts1990$CNT_CODE == "39061",]
dane_tracts_2000 = tracts2000[tracts2000$CNT_CODE == "39061",]
library(dplyr)
library(sf)
library(tmap)
library(kableExtra)
library(pals)
library(ggplot2)
library(areal)
library(gridExtra)
library(colourpicker)
entropy_fnc = function(proportions, base = exp(1)) {
entr = -sum(ifelse(proportions > 0, proportions * log(proportions, base = base), 0))
return(entr)
}
entropy_std_fnc = function(proportions, base = exp(1)) {
entr = -sum(ifelse(proportions > 0, proportions * log(proportions, base = base), 0)) #obliczenie entropii
entr_std = entr/log(length(proportions), base = base) #standaryzacja
return(entr_std)
}
d_ind = function(a, b) {
d = 0.5*sum(abs(a/sum(a, na.rm=TRUE) - b/sum(b, na.rm=TRUE)))
return(d)
}
hindex <- function(races) {
#races_all to liczba osob w calym obszarze w podziale na grupy rasowo-etniczne
races_all = apply(races, 2, sum, na.rm=TRUE)
#liczba osob w calym obszarze
pop = sum(races_all, na.rm=TRUE)
#liczba osob w kazdej jednostce spisowej
pop_i = apply(races, 1, sum, na.rm=TRUE)
#odsetek osob w danej grupy rasowo-etnicznej w kazdej jednostce spisowej
proportions = races/pop_i
#odsetek osob w danej grupy rasowo-etnicznej w calym obszarze
proportions_all = races_all/sum(races_all, na.rm = TRUE)
#entropia dla kazdej jednostki spisowej
ent_i = apply(proportions, 1, entropy_fnc)
#entropia dla calego obszaru
ent = entropy_fnc(proportions_all)
#obliczenie H
hind = sum(pop_i*(ent-ent_i)/(ent*pop), na.rm=TRUE)
return(hind)
}
tracts1990 = read_sf("dane/dane_przestrzenne/census_tracts_1990.shp")
tracts2000 = read_sf("dane/dane_przestrzenne/census_tracts_2000.shp")
dane_tracts_1990 = tracts1990[tracts1990$CNT_CODE == "39061",]
dane_tracts_2000 = tracts2000[tracts2000$CNT_CODE == "39061",]
fshp90 <- dane_tracts_1990
fshp00 <- dane_tracts_2000
rm(tracts1990, tracts2000, dane_tracts_1990, dane_tracts_2000)
list_race <- c("white", "black", "american", "asian", "others", "latin")
dat90 <- read_sf("dc_tract_1990_attr.shp")
dat00 <- read_sf("dc_tract_2000_attr.shp")
library(raster)
library(rgdal)
miedzyzdroje_ndvi <- raster("dane_gotowe/ndvi_miedzyzdroje_przyciete.tif")
setwd("E:/Projekty/wolin_2022/ocena_korelacji/ocena-korelacji-NDVI-main/ocena-korelacji-NDVI")
miedzyzdroje_ndvi <- raster("dane_gotowe/ndvi_miedzyzdroje_przyciete.tif")
plot(miedzyzdroje_ndvi)
hist(miedzyzdroje_ndvi)
raster <- mask(miedzyzdroje_ndvi, 0)
(tmap)
(tmap)
(tmap)
(tmap)
(tmap)
library(tmap)
library(raster)
library(rgdal)
library(ggplot2)
library(plotly)
library(spatialEco)
library(dplyr)
# wczytanie rastrów
ndvi_miedzyzdroje <- raster("dane_gotowe/ndvi_miedzyzdroje.tif")
temp_miedzyzdroje <- raster("dane_gotowe/temp_miedzyzdroje.tif")
ndvi_WPN <- raster("dane_gotowe/ndvi_WPN.tif")
temp_WPN <- raster("dane_gotowe/temp_WPN.tif")
ndvi_WPN <- raster("ndvi_probne.tif")
temp_WPN <- raster("temp_probne.tif")
# podglad warstwy
tm_shape(ndvi_miedzyzdroje) + tm_raster()
ggplotly(ndvi_miedzyzdroje)
plot_ly(ndvi_miedzyzdroje)
plot_geo(ndvi_miedzyzdroje)
plot_geo(ndvi_miedzyzdroje, x = ~Lat, y = ~Lon) )
plot_geo(ndvi_miedzyzdroje, x = ~Lat, y = ~Lon)
library(leaflet)
leaflet() %>%
addRasterImage(r)
leaflet() %>%
addRasterImage(ndvi_WPN)
a <- leaflet() %>%
addRasterImage(ndvi_WPN)
ggplotly(a)
plot_ly(a)
install.packages("rasterly")
library(rasterly)
plot_ly(ndvi_WPN, x = ~Lat, y = ~Lon) %>%
add_rasterly_heatmap()
r <- as.raster(matrix(hcl(0, 80, seq(50, 80, 10)), nrow = 4, ncol = 5))
plot(r)
# embed the raster as an image
plot_ly(x = 1, y = 1) %>%
layout(
images = list(list(
source = raster2uri(r),
xref = "paper",
yref = "paper",
x = 0, y = 0,
sizex = 0.5, sizey = 0.5,
xanchor = "left", yanchor = "bottom"
))
)
plot_ly(ndvi_WPN, x = ~Lat, y = ~Lon) %>%
add_rasterly_heatmap()
leaflet() %>%
addRasterImage(ndvi_WPN)
